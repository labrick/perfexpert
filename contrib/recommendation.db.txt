
-- Table: attribute
CREATE TABLE attribute ( 
    attr_code INTEGER     NOT NULL,
    attr_desc CHAR( 32 )  NOT NULL 
);

INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (1, 'loop1');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (2, 'loop2');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (4, 'loop3');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (8, 'multiple_loops');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (16, 'multiple_functions');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (32, 'boost');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (64, 'd-L1');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (128, 'd-L2');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (256, 'd-mem');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (512, 'd-tlb');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (1024, 'i-access');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (2048, 'i-tlb');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (4096, 'br-i');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (8192, 'fpt-fast');
INSERT INTO [attribute] ([attr_code], [attr_desc]) VALUES (16384, 'fpt-slow');

-- Table: recommendation
CREATE TABLE recommendation ( 
    [desc]    CHAR( 1024 )  NOT NULL,
    reason    CHAR( 1024 )  NOT NULL,
    code      CHAR( 1024 ),
    flags     CHAR( 254 ),
    attr_code INTEGER       NOT NULL,
    counter   INTEGER       PRIMARY KEY
                            NOT NULL 
);

INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('eliminate common subexpressions involving memory accesses', 'this optimization reduces the number of executed (slow) memory accesses', 'd[i] = a * b[i] + c[i];
y[i] = a * b[i] + x[i];
 =====>
temp = a * b[i];
d[i] = temp + c[i];
y[i] = temp + x[i];', null, 64, 1);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('eliminate floating-point operations through distributivity', 'this optimization reduces the number of executed floating-point operations', 'd[i] = a[i] * b[i] + a[i] * c[i];
 =====>
d[i] = a[i] * (b[i] + c[i]);', null, 24576, 2);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('eliminate floating-point operations through associativity', 'this optimization reduces the number of executed floating-point operations', 'd[i] = a[i] * b[i] * c[i];
y[i] = x[i] * a[i] * b[i];
 =====>
temp = a[i] * b[i];
d[i] = temp * c[i];
y[i] = x[i] * temp;', null, 24576, 3);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('move loop invariant computations out of loop', 'this optimization reduces the number of executed floating-point operations', 'loop i {
  x = x + a * b * c[i];
}
 =====>
temp = a * b;
loop i {
  x = x + temp * c[i];
}', null, 24577, 4);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('use float instead of double data type if loss of precision is acceptable', 'this optimization reduces the amount of memory required to store floating-point
data, which often makes accessing the data faster', 'double a[n];
 =====>
float a[n];', null, 16448, 5);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('compare squared values instead of computing the square root', 'this optimization replaces a slow operation with equivalent but much faster
operations', 'if (x < sqrt(y)) {...}
 =====>
if ((x < 0.0) || (x*x < y)) {...}', null, 16384, 6);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('compute the reciprocal outside of loop and use multiplication inside the loop', 'this optimization replaces many slow operations with one slow and many fast
operations that accomplish the same', 'loop i {
  a[i] = b[i] / c;
}
 =====>
cinv = 1.0 / c;
loop i {
  a[i] = b[i] * cinv;
}', null, 16385, 7);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('accumulate and then normalize instead of normalizing each element', 'this optimization replaces many slow operations with a single slow operation
that accomplishes the same', 'loop i {
  x = x + a[i] / b;
}
 =====>
loop i {
  x = x + a[i];
}
x = x / b;', null, 16385, 8);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('use trivial assignments inside THEN/ELSE to allow the use of conditional moves', 'this optimization may allow the compiler to replace a code sequence with an
equivalent but faster code sequence that uses no branches', 'if (x < y)
  a = x + y;
 =====>
temp = x + y;
if (x < y)
  a = temp;', null, 4096, 9);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('express Boolean logic in form of integer computation', 'this optimization replaces a code sequence with an equivalent code sequence that
is faster because fewer branches are executed', 'if ((a == 0) && (b == 0) && (c == 0)) {...}
 =====>
if ((a | b | c) == 0) {...}', null, 4096, 10);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('remove IF', 'this optimization replaces a code sequence with an equivalent code sequence that
may be faster because no branches are needed', '/* x is 0 or -1 */
if (x == 0)
  a = b;
else
  a = c;
 =====>
a = (b & ~x) | (c & x);', null, 4096, 11);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('unroll loops (more)', 'this optimization replaces a code sequence with an equivalent code sequence that
is faster because fewer branches are executed', 'loop i {
  a[i] = a[i] * b[i];
}
 =====>
loop i step 2 {
  a[i] = a[i] * b[i];
  a[i+1] = a[i+1] * b[i+1];
}', null, 4097, 12);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('move a loop around a subroutine call into the subroutine', 'this optimization replaces a code sequence with an equivalent code sequence that
is faster because fewer calls are executed', 'f(x) {...x...};
loop i {
  f(a[i]);
}
 =====>
f(x[]) {
  loop j {
    ...x[j]...
  }
};
f(a);', null, 4097, 13);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('move loop invariant tests out of loop', 'this optimization replaces a code sequence with an equivalent code sequence that is faster because fewer branches are executed', 'loop i {
  if (x < y)
    a[i] = x * b[i];
  else
    a[i] = y * b[i];
}
 =====>
if (x < y) {
  loop i {
    a[i] = x * b[i];
  }
} else {
  loop i {
    a[i] = y * b[i];
  }
}', null, 4097, 14);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('special-case the most often used loop count(s)', 'this optimization replaces a code sequence with an equivalent sequence that is faster because fixed loop boundaries often enable better compiler optimizations', 'for (i = 0; i < n; i++) {...}
 =====>
if (n == 4) {
  for (i = 0; i < 4; i++) {...}
} else {
  for (i = 0; i < n; i++) {...}
}', null, 4097, 15);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('use inlining', 'this optimization replaces a code sequence with an equivalent code sequence that is faster because fewer control transfers are executed', 'float f(float x) {
  return x * x;
}
z = f(y);
 =====>
z = y * y;', 'use the "-inline-forceinline", "-finline", "-finline-functions", or "-finline-limit=<n>" (with a large <n>) compiler flags', 2048, 16);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('change the order of subroutine calls', 'this optimization, when allowed, may yield faster execution when it results in more opportunity for compiler optimizations', 'f(); h();
 =====>
h(); f();', null, 2064, 17);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('factor out sequences of common code into subroutines', 'this optimization reduces the code size, which may improve the instruction cache performance', 'same_code;
same_code;
 =====>
void f() {same_code;}
f();
f();', null, 1056, 18);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('sort subroutines by call chains (subroutine coloring)', 'this optimization moves functions to potentially better starting addresses in memory', 'f() {...}
g() {...}
h() {...}
loop {
  f();
  h();
}
 =====>
g() {...}
f() {...}
h() {...}
loop {
  f();
  h();
}', null, 3088, 19);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('lower the loop unroll factor', 'this optimization reduces the code size, which may improve the instruction cache performance', 'loop i step 4 {
  code_i;
  code_i+1;
  code_i+2;
  code_i+3;
}
 =====>
loop i step 2 {
  code_i;
  code_i+1;
}', 'use the "-no-unroll-aggressive" compiler flag', 1025, 20);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('make subroutines more general and use them more', 'this optimization reduces the code size, which may improve the instruction cache performance', 'void f() {
  statements1;
  statementsX;
}
void g() {
  statements2;
  statementsX;
}
 =====>
void fg(int flag) {
  if (flag) {
    statements1;
  } else {
    statements2;
  }
  statementsX;
}', null, 1040, 21);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('split off cold code into separate subroutines and place them at end of file', 'this optimization separates rarely from frequently used code, which may improve the instruction cache performance', 'if (unlikely_condition) {
  lots_of_code
}
 =====>
void f() {lots_of_code}
...
if (unlikely_condition)
  f();', null, 1024, 22);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('use trace scheduling to reduce the branch taken frequency', 'this optimization replaces a code sequence with an equivalent code sequence that may be faster because it reduces (taken) branches and may enable better compiler optimizations', 'if (likely_condition)
  f();
else
  g();
h();
 =====>
if (!likely_condition) {
  g(); h();
} else {
  f(); h();
}', null, 1040, 23);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('move loop invariant memory accesses out of loop', 'this optimization reduces the number of executed (slow) memory accesses', 'loop i {
  a[i] = b[i] * c[j]
}
 =====>
temp = c[j];
loop i {
  a[i] = b[i] * temp;
}', null, 97, 24);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('compute values rather than loading them if doable with few operations', 'this optimization replaces (slow) memory accesses with equivalent but faster computations', 'loop i {
  t[i] = a[i] * 0.5;
}
loop i {
  a[i] = c[i] - t[i];
}
 =====>
loop i {
  a[i] = c[i] - (a[i] * 0.5);
}', null, 385, 25);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('enable the use of vector instructions to transfer more data per access', 'this optimization increases the memory bandwidth', 'align arrays, use only stride-one accesses, make loop count even (pad arrays)
struct {
  double a, b;
} s[127];
for (i = 0; i < 127; i++) {
  s[i].a = 0;
  s[i].b = 0;
}
 =====>
__declspec(align(16)) double a[128], b[128];
for (i = 0; i < 128; i++) {
  a[i] = 0;
  b[i] = 0;
}', 'use the "-opt-streaming-stores always" compiler flag', 65, 26);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('copy data into local scalar variables and operate on the local copies', 'this optimization replaces (slow) memory accesses with equivalent but faster computations', 'x = a[i] * a[i];
...
a[i] = x / b;
...
b = a[i] + 1.0;
 =====>
t = a[i];
x = t * t;
...
a[i] = t = x / b;
...
b = t + 1.0;', 'use the "-scalar-rep" compiler flag', 64, 27);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('align data, especially arrays and structs', 'this optimization enables the use of vector instructions, which increase the memory bandwidth', 'int x[1024];
 =====>
__declspec(align(16)) int x[1024];', 'use the "-Zp16", "-malign-double", and/or "-malign-natural" compiler flags', 64, 28);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('help the compiler by marking pointers to non-overlapping data with "restrict"', 'this optimization, when applicable, enables the compiler to tune the code more aggressively', 'void *a, *b;
 =====>
void * restrict a, * restrict b;', 'use the "-restrict" compiler flag', 64, 29);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('fuse multiple loops that access the same data', 'this optimization enables the reuse of loaded data', 'loop i {
  a[i] = x[i];
}
loop i {
  b[i] = x[i] - 1;
}
 =====>
loop i {
  a[i] = x[i];
  b[i] = x[i] - 1;
}', null, 393, 30);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('change the order of loops', 'this optimization may improve the memory access pattern and make it more cache and TLB friendly', 'loop i {
  loop j {...}
}
 =====>
loop j {
  loop i {...}
}', null, 770, 31);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('employ loop blocking and interchange', 'this optimization may improve the memory access pattern and make it more cache and TLB friendly, choose s such that s*s+2*s is less than the cache size', 'loop i {
  loop k {
    loop j {
      c[i][j] = c[i][j] + a[i][k] * b[k][j];
    }
  }
}
 =====>
loop k step s {
  loop j step s {
    loop i {
      for (kk = k; kk < k + s; kk++) {
        for (jj = j; jj < j + s; jj++) {
          c[i][jj] = c[i][jj] + a[i][kk] * b[kk][jj];
        }
      }
    }
  }
}', null, 260, 32);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('unroll outer loop', 'this optimization may reduce the number of (slow) memory accesses', 'loop i {
  loop j {
    a[i][j] = b[i][j] * c[j];
  }
}
 =====>
loop i step 4 {
  loop j {
    a[i][j] = b[i][j] * c[j];
    a[i+1][j] = b[i+1][j] * c[j];
    a[i+2][j] = b[i+2][j] * c[j];
    a[i+3][j] = b[i+3][j] * c[j];
  }
}', null, 66, 33);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('access arrays directly instead of using local copies', 'this optimization reduces the memory footprint, which may improve cache performance', 'loop j {
  a[j] = b[i][j][k];
}
...
loop j {
  ... a[j] ...
}
 =====>
loop j {
  ... b[i][j][k] ...
}', null, 385, 34);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('reuse temporary arrays for different operations', 'this optimization reduces the memory footprint, which may improve cache performance', 'loop i {
  t1[i] = ...;
  ... t1[i] ...;
}
...
loop j {
  t2[j] = ...;
  ... t2[j] ...;
}
 =====>
loop i {
  t[i] = ...;
  ... t[i] ...;
}
...
loop j {
  t[j] = ...;
  ... t[j] ...;
}', null, 385, 35);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('avoid unnecessary array updates', 'this optimization reduces the number of memory writes', 'loop i {
  a[i] = ...;
  ... a[i] ...
}
// array a[] not read
 =====>
loop i {
  temp = ...;
  ... temp ...
}', null, 385, 36);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('use smaller types (e.g., float instead of double or short instead of int)', 'this optimization reduces the memory footprint, which may improve cache performance', 'double a[n];
 =====>
float a[n];', null, 768, 37);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('apply loop fission so every loop accesses just a couple of different arrays', 'this optimization reduces the number of active memory pages, which may improve DRAM performance', 'loop i {
  a[i] = a[i] * b[i] - c[i];
}
 =====>
loop i {
  a[i] = a[i] * b[i];
}
loop i {
  a[i] = a[i] - c[i];
}', null, 257, 38);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('componentize important loops by factoring them into their own subroutines', 'this optimization may allow the compiler to optimize the loop independently and thus tune it better', 'loop i {...}
...
loop j {...}
 =====>
void li() {loop i {...}}
void lj() {loop j {...}}
...
li();
...
lj();', null, 449, 39);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('split structs into hot and cold parts, where hot part has pointer to cold part', 'this optimization separates rarely and frequently used data, which may improve cache performance', 'struct s {
  hot_field;
  many_cold_fields;
} a[n];
 =====>
struct s_hot {
  hot_field;
  struct s_cold *ptr;
} a_hot[n];
struct s_cold {
  many_cold_fields;
} a_cold[n];', null, 256, 40);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('pad memory areas so that temporal elements do not map to same set in cache', 'this optimization reduces the chance of data overlap in the caches, which may improve cache performance, the final size of each array should be an integer multiple of the cache line size (typically 64 bytes) but should not be a small integer multiple of the cache size', 'double a[const * cache_size/8], b[const * cache_size/8];
loop i {
  ... a[i] + b[i] ...
}
 =====>
double a[const * cache_size/8 + 8], b[const * cache_size/8 + 8];
loop i {
  ... a[i] + b[i] ...
}', null, 257, 41);
INSERT INTO [recommendation] ([desc], [reason], [code], [flags], [attr_code], [counter]) VALUES ('allocate an array of elements instead of each element individually', 'this optimization reduces the memory footprint and enhances spatial locality, which may improve cache performance', 'loop {
  ... c = malloc(1); ...
}
 =====>
top = n;
loop {
  if (top == n) {
    tmp = malloc(n);
    top = 0;
  }
  ...
  c = &tmp[top++]; ...
}', null, 257, 42);

-- Index: idx_attribute
CREATE INDEX idx_attribute ON attribute ( 
    attr_code 
);

